@input_pool = internal global %struct.anon { %struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }, i64 0, i32 0 }, align 8, !dbg !0 NUM USES:1, TYPE:%struct.anon*
For:input_pool: of type (1,1,0):%struct.anon*:%struct.anon = type { %struct.blake2s_state, i64, i32 }, Struct Type:1 Num fields:3
Operand (1) :Is Function:0
%struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }
Operand (2) :Is Function:0
i64 0
Operand (3) :Is Function:0
i32 0

[33maddGlobalTaintSource(): Set the glob var as taint source: [0m@input_pool = internal global %struct.anon { %struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }, i64 0, i32 0 }, align 8, !dbg !0
AliasObject::setAsTaintSrc(): set as taint src, obj: 0x1d542e0
FieldTaint::addTf(): add TF for field -1, FieldTaint: 0x1d54390, Host: 0x0
FieldTaint::addTf(): +++TF: TAG(0x1d57880):struct.anon|-1(OBJ:0x1d542e0,G:1) TF(0x1d56770)  FROM:  TO:  tr_len: 0 tan/inh/act/wea: 1/1/1/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 1/1/1/1/0
AliasObject::setAsTaintSrc(): Updating field taint for obj: 0x1d542e0
AliasObject::setAsTaintSrc(): Adding taint to: 0x1d542e0 | 0
AliasObject::addFieldTaintFlag(): %struct.anon = type { %struct.blake2s_state, i64, i32 } | 0 obj: 0x1d542e0
FieldTaint::addTf(): add TF for field 0, FieldTaint: 0x1d24170, Host: 0x1d542e0
FieldTaint::addTf(): +++TF: TAG(0x1d57a10):struct.anon|0(OBJ:0x1d542e0,G:1) TF(0x1d57a40)  FROM:  TO:  tr_len: 0 tan/inh/act/wea: 1/1/1/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 1/1/1/1/0
AliasObject::setAsTaintSrc(): Adding taint to: 0x1d542e0 | 1
AliasObject::addFieldTaintFlag(): %struct.anon = type { %struct.blake2s_state, i64, i32 } | 1 obj: 0x1d542e0
FieldTaint::addTf(): add TF for field 1, FieldTaint: 0x1d57bd0, Host: 0x1d542e0
FieldTaint::addTf(): +++TF: TAG(0x1d57b30):struct.anon|1(OBJ:0x1d542e0,G:1) TF(0x1d57b60)  FROM:  TO:  tr_len: 0 tan/inh/act/wea: 1/1/1/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 1/1/1/1/0
AliasObject::setAsTaintSrc(): Adding taint to: 0x1d542e0 | 2
AliasObject::addFieldTaintFlag(): %struct.anon = type { %struct.blake2s_state, i64, i32 } | 2 obj: 0x1d542e0
FieldTaint::addTf(): add TF for field 2, FieldTaint: 0x1d57d20, Host: 0x1d542e0
FieldTaint::addTf(): +++TF: TAG(0x1d57c80):struct.anon|2(OBJ:0x1d542e0,G:1) TF(0x1d57cb0)  FROM:  TO:  tr_len: 0 tan/inh/act/wea: 1/1/1/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 1/1/1/1/0
[33maddGlobalTaintSource(): Set the alias obj as taint source:
[0mObject Type: %struct.anon = type { %struct.blake2s_state, i64, i32 }
 Object Ptr: %struct.anon { %struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }, i64 0, i32 0 }
getTargetFunctions: Functions to analyze:
FUNC: entry0 PTR: 0x1d1b298 TYPE: MY_IOCTL USER_ARGS: 1
[TIMING] Analysis starts at: Sat Nov 22 06:06:23 2025

=========================Preliminary Analysis Phase=========================
=========================Main Analysis Phase=========================
[32m[GREEN] Hello from TaintAnalysisVisitor![0m
TaintUtils::updateTaintInfo() for: i8 %1
No existing taint info, insert all 1
+++TF: TAG(0x1d59310):i8|0(OBJ:0x0,G:0) TF(0x1d59340)  FROM:   %3 = alloca i32, align 4 (entry0 -> ) TO:   %3 = alloca i32, align 4 (entry0 -> ) tr_len: 1 tan/inh/act/wea: 1/0/1/0
CTX: entry0 ->
[TIMING] Start func(1) entry0: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:entry0[0m
updatePointsToObjects for :   %3 = alloca i32, align 4
InstructionUtils::inferPointeeTy() for:   %3 = alloca i32, align 4
InstructionUtils::inferPointeeTy(): candidate types: i32 | 
InstructionUtils::inferPointeeTy(): res type: i32
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: i32
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: i32 | 0 ,is_taint_src: 0, Obj ID: 0x1d200b0, Inst/Val:   %3 = alloca i32, align 4, loadTag: 
updatePointsToObjects: #After update: 1
updatePointsToObjects for :   %4 = alloca [256 x i8], align 16
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: [256 x i8]
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [256 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d0ce00, Inst/Val:   %4 = alloca [256 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
AliasAnalysisVisitor::visitStoreInst():   store i32 %0, i32* %3, align 4, !tbaa !49
visitStoreInst(): src does not point to anything: i32 %0; Ignoring.
TaintAnalysisVisitor::visitStoreInst():   store i32 %0, i32* %3, align 4, !tbaa !49
AliasObject::getNestedObj(): 0x1d200b0 | 0 : i32
AliasObject::addFieldTaintFlag(): i32 | 0 obj: 0x1d200b0
AliasObject::addFieldTaintFlag(): try to add a taint kill flag, but the target                field hasn't been tainted yet, so no action...
[TIMING] TaintAnalysisVisitor::visitStoreInst(): 2.602000e-05s
AliasAnalysisVisitor::visitGetElementPtrInst():   %5 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0, !dbg !53
AliasAnalysisVisitor::processGEPFirstDimension():: basePointerTy: [256 x i8]*
AliasAnalysisVisitor::processGEPFirstDimension(): 0st index: 0
About to process index: 1
Index value: 0
AliasAnalysisVisitor::makePointsToCopy(): #elements in *srcPointsTo: 1 
AliasAnalysisVisitor::makePointsToCopy(): basePointerType: [256 x i8]* cur pto: [256 x i8] | 0, obj: 0x1d0ce00 dst fid: 0
AliasAnalysisVisitor::makePointsToCopy(): ++ ret pto: [256 x i8] | 0, obj: 0x1d0ce00
AliasAnalysisVisitor::makePointsToCopy(): #ret: 1
AliasAnalysisVisitor::processMultiDimensionGEP(): updating the point-to for current GEP...
updatePointsToObjects for :   %5 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy() for:   %5 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy(): candidate types: i8 | 
InstructionUtils::inferPointeeTy(): res type: i8
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: i8
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [256 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d0ce00, Inst/Val:   %4 = alloca [256 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
[TIMING] AliasAnalysisVisitor::visitGetElementPtrInst(): 1.193800e-04s
GlobalVisitor::processCalledFunction: prepare context for: llvm.lifetime.start.p0i8 (w/o definition)
AliasAnalysisVisitor::visitCallInst():   call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %5) #4, !dbg !53
AliasAnalysisVisitor::visitCallInst(): Handle the Function: llvm.lifetime.start.p0i8 in the default way.
AliasAnalysisVisitor::visitCallInst(): not handled!
PathAnalysisVisitor::visitCallInst():   call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %5) #4, !dbg !53, callee: llvm.lifetime.start.p0i8
GlobalVisitor::processCalledFunction: prepare context for: copy_from_user (w/o definition)
AliasAnalysisVisitor::visitCallInst():   %6 = call i32 (i8*, i32*, i32, ...) bitcast (i32 (...)* @copy_from_user to i32 (i8*, i32*, i32, ...)*)(i8* nonnull %5, i32* nonnull %3, i32 256) #4, !dbg !55
AliasAnalysisVisitor::visitCallInst(): This is a copy_from_user function.
Current argument:   %5 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy() for:   %5 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy(): res type: i8
[DST PTO] [256 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d0ce00, Inst/Val:   %4 = alloca [256 x i8], align 16, loadTag: 
AliasAnalysisVisitor::handleCfuFunction(): Try to create a new dummy dst obj to init the user taint!
AliasObject::setAsTaintSrc(): set as taint src, obj: 0x1d5bac0
FieldTaint::addTf(): add TF for field -1, FieldTaint: 0x1d5bb70, Host: 0x0
FieldTaint::addTf(): +++TF: TAG(0x1d5bce0):i32|-1(OBJ:0x1d5bac0,G:0) TF(0x1d5a5c0)  FROM:  TO:  tr_len: 0 tan/inh/act/wea: 1/1/1/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 1/1/1/1/0
AliasObject::setAsTaintSrc(): Updating field taint for obj: 0x1d5bac0
AliasObject::setAsTaintSrc(): Adding taint to: 0x1d5bac0 | 0
AliasObject::addFieldTaintFlag(): i8 | 0 obj: 0x1d5bac0
FieldTaint::addTf(): add TF for field 0, FieldTaint: 0x1d5c290, Host: 0x1d5bac0
FieldTaint::addTf(): +++TF: TAG(0x1d5c1f0):i32|0(OBJ:0x1d5bac0,G:0) TF(0x1d5c220)  FROM:  TO:  tr_len: 0 tan/inh/act/wea: 1/1/1/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 1/1/1/1/0
updatePointsToObjects for :   %5 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy() for:   %5 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy(): res type: i8
#newPointsToInfo: 1 #existingPointsTo: 1 expected pointee type: i8
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: i8 | 0 ,is_taint_src: -1, Obj ID: 0x1d5bac0, Inst/Val:   %6 = call i32 (i8*, i32*, i32, ...) bitcast (i32 (...)* @copy_from_user to i32 (i8*, i32*, i32, ...)*)(i8* nonnull %5, i32* nonnull %3, i32 256) #4, !dbg !55, loadTag: 
updatePointsToObjects: #After update: 2
PathAnalysisVisitor::visitCallInst():   %6 = call i32 (i8*, i32*, i32, ...) bitcast (i32 (...)* @copy_from_user to i32 (i8*, i32*, i32, ...)*)(i8* nonnull %5, i32* nonnull %3, i32 256) #4, !dbg !55, callee: copy_from_user
GlobalVisitor::processCalledFunction: prepare context for: random_write_iter (w/ definition)
AliasAnalysisVisitor::visitCallInst():   call fastcc void @random_write_iter(i8* nonnull %5), !dbg !56
AliasAnalysisVisitor::setupCallContext(): arg 1 has points to information
PathAnalysisVisitor::visitCallInst():   call fastcc void @random_write_iter(i8* nonnull %5), !dbg !56, callee: random_write_iter
Analyzing new function: random_write_iter Call depth: 3
CTX: entry0 -> random_write_iter -> 
[TIMING] Start func(3) random_write_iter: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:random_write_iter[0m
GlobalVisitor::processCalledFunction: prepare context for: write_pool_user (w/ definition)
AliasAnalysisVisitor::visitCallInst():   call fastcc void @write_pool_user(i8* %0), !dbg !53
AliasAnalysisVisitor::setupCallContext(): arg 1 has points to information
PathAnalysisVisitor::visitCallInst():   call fastcc void @write_pool_user(i8* %0), !dbg !53, callee: write_pool_user
Analyzing new function: write_pool_user Call depth: 5
CTX: entry0 -> random_write_iter -> write_pool_user -> 
[TIMING] Start func(5) write_pool_user: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:write_pool_user[0m
updatePointsToObjects for :   %2 = alloca [64 x i8], align 16
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: [64 x i8]
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
AliasAnalysisVisitor::visitGetElementPtrInst():   %3 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 0, !dbg !53
AliasAnalysisVisitor::processGEPFirstDimension():: basePointerTy: [64 x i8]*
AliasAnalysisVisitor::processGEPFirstDimension(): 0st index: 0
About to process index: 1
Index value: 0
AliasAnalysisVisitor::makePointsToCopy(): #elements in *srcPointsTo: 1 
AliasAnalysisVisitor::makePointsToCopy(): basePointerType: [64 x i8]* cur pto: [64 x i8] | 0, obj: 0x1d2ae60 dst fid: 0
AliasAnalysisVisitor::makePointsToCopy(): ++ ret pto: [64 x i8] | 0, obj: 0x1d2ae60
AliasAnalysisVisitor::makePointsToCopy(): #ret: 1
AliasAnalysisVisitor::processMultiDimensionGEP(): updating the point-to for current GEP...
updatePointsToObjects for :   %3 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy() for:   %3 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy(): candidate types: i8 | 
InstructionUtils::inferPointeeTy(): res type: i8
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: i8
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
[TIMING] AliasAnalysisVisitor::visitGetElementPtrInst(): 1.185790e-04s
GlobalVisitor::processCalledFunction: prepare context for: llvm.lifetime.start.p0i8 (w/o definition)
AliasAnalysisVisitor::visitCallInst():   call void @llvm.lifetime.start.p0i8(i64 64, i8* nonnull %3) #4, !dbg !53
AliasAnalysisVisitor::visitCallInst(): Handle the Function: llvm.lifetime.start.p0i8 in the default way.
AliasAnalysisVisitor::visitCallInst(): not handled!
PathAnalysisVisitor::visitCallInst():   call void @llvm.lifetime.start.p0i8(i64 64, i8* nonnull %3) #4, !dbg !53, callee: llvm.lifetime.start.p0i8
AliasAnalysisVisitor::visitCastInst:   %4 = ptrtoint [64 x i8]* %2 to i64, !dbg !55
Convert: [64 x i8]* --> i64
srcOperand:   %2 = alloca [64 x i8], align 16
AliasAnalysisVisitor::visitCastInst(): current target object: [64 x i8] | 0
AliasAnalysisVisitor::visitCastInst(): the cast destination is not a pointer                , simply propagate the point-to record from src to dst...
updatePointsToObjects for :   %4 = ptrtoint [64 x i8]* %2 to i64, !dbg !55
InstructionUtils::inferPointeeTy() for:   %4 = ptrtoint [64 x i8]* %2 to i64, !dbg !55
InstructionUtils::inferPointeeTy(): candidate types: 
InstructionUtils::inferPointeeTy(): res type: 
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: 
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
[32mStarting to analyze BB::at:write_pool_user[0m
GlobalVisitor::processCalledFunction: prepare context for: llvm.memcpy.p0i8.p0i8.i64 (w/o definition)
AliasAnalysisVisitor::visitCallInst():   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62
AliasAnalysisVisitor::visitCallInst(): This is a memcpy function w/o definition.
AliasAnalysisVisitor::handleMemcpyFunction(): Processing memcpy function.
AliasAnalysisVisitor::getMemcpySrcTy(): memcpy size: 64
InstructionUtils::inferPointeeTy() for:   %3 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 0, !dbg !53
InstructionUtils::inferPointeeTy(): res type: i8
InstructionUtils::inferPointeeTy() for: i8* %0
InstructionUtils::inferPointeeTy(): candidate types: i8 | 
InstructionUtils::inferPointeeTy(): res type: i8
AliasAnalysisVisitor::getMemcpySrcTy(): try to find the type nearest to the memcpy size.
AliasAnalysisVisitor::handleMemcpyFunction(): inferred memcpy ty: i8
[DST PTO] [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
AliasObject::mergeField(): 0x1d0ce00|0 -> 0x1d2ae60|0

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62
[256 x i8] | 0 OBJ: 0x1d0ce00
Object Ptr:   %4 = alloca [256 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d0ce00 | 0 : i8
AliasObject::fetchPointsToObjects: equivalent obj|field identified, cnt: 2
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d0ce00|-1

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62
[256 x i8] | -1 OBJ: 0x1d0ce00
Object Ptr:   %4 = alloca [256 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d0ce00 | -1 : i8
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d0ce00|-1
AliasObject::mergeField(): 0x1d5bac0|0 -> 0x1d2ae60|0

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62
i8 | 0 OBJ: 0x1d5bac0
Object Ptr:   %6 = call i32 (i8*, i32*, i32, ...) bitcast (i32 (...)* @copy_from_user to i32 (i8*, i32*, i32, ...)*)(i8* nonnull %5, i32* nonnull %3, i32 256) #4, !dbg !55
*******************
AliasObject::getNestedObj(): 0x1d5bac0 | 0 : i8
FieldTaint::getTf(): fetch taint for field: 0, FieldTaint: 0x1d5c290, Host: 0x1d5bac0
FieldTaint::getTf(): final stats: total/act_tan/ret: 1/1/1
AliasObject::addFieldTaintFlag(): [64 x i8] | 0 obj: 0x1d2ae60
FieldTaint::addTf(): add TF for field 0, FieldTaint: 0x1d5fa50, Host: 0x1d2ae60
FieldTaint::addTf(): +++TF: TAG(0x1d5c1f0):i32|0(OBJ:0x1d5bac0,G:0) TF(0x1d5f9c0)  FROM:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62 (entry0 -> random_write_iter -> write_pool_user -> ) TO:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62 (entry0 -> random_write_iter -> write_pool_user -> ) tr_len: 1 tan/inh/act/wea: 1/0/1/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 1/1/1/0/0
[1;94m Processing memcpy function
[0mPathAnalysisVisitor::visitCallInst():   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62, callee: llvm.memcpy.p0i8.p0i8.i64
GlobalVisitor::processCalledFunction: prepare context for: mix_pool_bytes (w/ definition)
AliasAnalysisVisitor::visitCallInst():   call fastcc void @mix_pool_bytes(i8* nonnull %3, i64 %4), !dbg !63
AliasAnalysisVisitor::setupCallContext(): arg 1 has points to information
AliasAnalysisVisitor::setupCallContext(): arg 2 has points to information
PathAnalysisVisitor::visitCallInst():   call fastcc void @mix_pool_bytes(i8* nonnull %3, i64 %4), !dbg !63, callee: mix_pool_bytes
Analyzing new function: mix_pool_bytes Call depth: 7
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> 
[TIMING] Start func(7) mix_pool_bytes: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:mix_pool_bytes[0m
GlobalVisitor::processCalledFunction: prepare context for: _mix_pool_bytes (w/ definition)
AliasAnalysisVisitor::visitCallInst():   call fastcc void @_mix_pool_bytes(i8* %0, i64 %1), !dbg !48
AliasAnalysisVisitor::setupCallContext(): arg 1 has points to information
AliasAnalysisVisitor::setupCallContext(): arg 2 has points to information
PathAnalysisVisitor::visitCallInst():   call fastcc void @_mix_pool_bytes(i8* %0, i64 %1), !dbg !48, callee: _mix_pool_bytes
Analyzing new function: _mix_pool_bytes Call depth: 9
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> 
[TIMING] Start func(9) _mix_pool_bytes: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:_mix_pool_bytes[0m
GlobalVisitor::processCalledFunction: prepare context for: blake2s_update (w/ definition)
AliasAnalysisVisitor::visitCallInst():   call void @blake2s_update(%struct.blake2s_state* getelementptr inbounds (%struct.anon, %struct.anon* @input_pool, i64 0, i32 0), i8* %0, i64 %1), !dbg !47
AliasAnalysisVisitor::handleInlinePointerOp(): Got pto by stripping cast: %struct.blake2s_state* getelementptr inbounds (%struct.anon, %struct.anon* @input_pool, i64 0, i32 0) -> @input_pool = internal global %struct.anon { %struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }, i64 0, i32 0 }, align 8, !dbg !0
AliasAnalysisVisitor::setupCallContext(): arg 1 has points to information
AliasAnalysisVisitor::setupCallContext(): arg 2 has points to information
AliasAnalysisVisitor::setupCallContext(): arg 3 has points to information
PathAnalysisVisitor::visitCallInst():   call void @blake2s_update(%struct.blake2s_state* getelementptr inbounds (%struct.anon, %struct.anon* @input_pool, i64 0, i32 0), i8* %0, i64 %1), !dbg !47, callee: blake2s_update
Analyzing new function: blake2s_update Call depth: 11
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> blake2s_update -> 
[TIMING] Start func(11) blake2s_update: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:blake2s_update[0m
AliasAnalysisVisitor::visitGetElementPtrInst():   %4 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 4, !dbg !51
AliasAnalysisVisitor::processGEPFirstDimension():: basePointerTy: %struct.blake2s_state*
AliasAnalysisVisitor::processGEPFirstDimension(): 0st index: 0
About to process index: 1
Index value: 4
AliasAnalysisVisitor::makePointsToCopy(): #elements in *srcPointsTo: 1 
AliasAnalysisVisitor::makePointsToCopy(): basePointerType: %struct.blake2s_state* cur pto: %struct.anon = type { %struct.blake2s_state, i64, i32 } | 0, obj: 0x1d542e0 dst fid: 4
AliasObject::createEmbObj(): host type: %struct.anon = type { %struct.blake2s_state, i64, i32 } | 0 ID: 0x1d542e0
AliasObject::createEmbObj(): ety: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } expectedPointeeTy: 
AliasObject::createEmbObj(): find the previosuly created embed object: 0x1d544e0
AliasAnalysisVisitor::makePointsToCopy(): ++ ret pto: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 4, obj: 0x1d544e0
AliasAnalysisVisitor::makePointsToCopy(): #ret: 1
AliasAnalysisVisitor::processMultiDimensionGEP(): updating the point-to for current GEP...
updatePointsToObjects for :   %4 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 4, !dbg !51
InstructionUtils::inferPointeeTy() for:   %4 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 4, !dbg !51
InstructionUtils::inferPointeeTy(): candidate types: i32 | 
InstructionUtils::inferPointeeTy(): res type: i32
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: i32
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 4 ,is_taint_src: 0, Obj ID: 0x1d544e0, Inst/Val: %struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }, loadTag: 
updatePointsToObjects: #After update: 1
[TIMING] AliasAnalysisVisitor::visitGetElementPtrInst(): 1.437300e-04s
AliasAnalysisVisitor::visitLoadInst():   %5 = load i32, i32* %4, align 4, !dbg !51, !tbaa !52

*********FieldAccess(FETCH)**********
Current Inst:   %5 = load i32, i32* %4, align 4, !dbg !51, !tbaa !52
%struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 4 OBJ: 0x1d544e0
Object Ptr: %struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }
*******************
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
AliasObject::fetchPointsToObjects: No existing pto records for the field, try to create a dummy obj.
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
AliasObject::createFieldPointee(): cannot decide the type of the dummy obj!
AliasAnalysisVisitor::visitLoadInst(): #targetObjects: 1 #finalObjects: 0
[TIMING] AliasAnalysisVisitor::visitLoadInst(): 6.228000e-05s
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
[TIMING] TaintAnalysisVisitor::visitLoadInst(): 1.110000e-05s
AliasAnalysisVisitor::visitCastInst:   %7 = zext i32 %6 to i64, !dbg !58
Convert: i32 --> i64
srcOperand:   %6 = sub i32 64, %5, !dbg !57
Ignoring casting as pointer does not point to anything
[32mStarting to analyze BB::at:blake2s_update[0m
AliasAnalysisVisitor::visitCastInst:   %10 = zext i32 %5 to i64, !dbg !62
Convert: i32 --> i64
srcOperand:   %5 = load i32, i32* %4, align 4, !dbg !51, !tbaa !52
Ignoring casting as pointer does not point to anything
AliasAnalysisVisitor::visitGetElementPtrInst():   %11 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %10, !dbg !62
AliasAnalysisVisitor::processGEPFirstDimension():: basePointerTy: %struct.blake2s_state*
AliasAnalysisVisitor::processGEPFirstDimension(): 0st index: 0
About to process index: 1
Index value: 3
AliasAnalysisVisitor::makePointsToCopy(): #elements in *srcPointsTo: 1 
AliasAnalysisVisitor::makePointsToCopy(): basePointerType: %struct.blake2s_state* cur pto: %struct.anon = type { %struct.blake2s_state, i64, i32 } | 0, obj: 0x1d542e0 dst fid: 3
AliasObject::createEmbObj(): host type: %struct.anon = type { %struct.blake2s_state, i64, i32 } | 0 ID: 0x1d542e0
AliasObject::createEmbObj(): ety: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } expectedPointeeTy: 
AliasObject::createEmbObj(): find the previosuly created embed object: 0x1d544e0
AliasAnalysisVisitor::makePointsToCopy(): ++ ret pto: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 3, obj: 0x1d544e0
AliasAnalysisVisitor::makePointsToCopy(): #ret: 1
About to process index: 2
Index value: -1
subGEP:   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3
resGEP:   %11 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %10, !dbg !62
AliasAnalysisVisitor::makePointsToCopy_emb(): elements in *srcPointsTo: 1 
AliasAnalysisVisitor::makePointsToCopy_emb(): host_type: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 3
AliasAnalysisVisitor::makePointsToCopy_emb(): ety: [64 x i8] | -1
AliasAnalysisVisitor::makePointsToCopy_emb(): trying to get/create an object for the embedded struct/array..
AliasObject::createEmbObj(): host type: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 3 ID: 0x1d544e0
AliasObject::createEmbObj(): ety: [64 x i8] expectedPointeeTy: [64 x i8]
AliasObject::createEmbObj(): try to create a new embed object because there is no emb obj in cache...
createOutsideObj():   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3  |   : [64 x i8]*
createOutsideObj(): Try to create new outside object.
createOutsideObj(): New obj created: 0x1d63970
AliasObject::createEmbObj(): the embedded obj created: 0x1d544e0 | 3 --> 0x1d63970
AliasObject::createEmbObj(): try to taint the emb obj (all fields), #TaintFlag: 0
updatePointsToObjects for :   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: [64 x i8]
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d63970, Inst/Val:   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, loadTag: 
updatePointsToObjects: #After update: 1
AliasAnalysisVisitor::processMultiDimensionGEP(): updating the point-to for current GEP...
updatePointsToObjects for :   %11 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %10, !dbg !62
InstructionUtils::inferPointeeTy() for:   %11 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %10, !dbg !62
InstructionUtils::inferPointeeTy(): candidate types: i8 | 
InstructionUtils::inferPointeeTy(): res type: i8
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: i8
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | -1 ,is_taint_src: 0, Obj ID: 0x1d63970, Inst/Val:   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, loadTag: 
updatePointsToObjects: #After update: 1
[TIMING] AliasAnalysisVisitor::visitGetElementPtrInst(): 2.644040e-04s
GlobalVisitor::processCalledFunction: prepare context for: llvm.memcpy.p0i8.p0i8.i64 (w/o definition)
AliasAnalysisVisitor::visitCallInst():   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %11, i8* align 1 %1, i64 %7, i1 false), !dbg !64
AliasAnalysisVisitor::visitCallInst(): This is a memcpy function w/o definition.
AliasAnalysisVisitor::handleMemcpyFunction(): Processing memcpy function.
AliasAnalysisVisitor::getMemcpySrcTy(): memcpy size: 0
InstructionUtils::inferPointeeTy() for:   %11 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %10, !dbg !62
InstructionUtils::inferPointeeTy(): res type: i8
InstructionUtils::inferPointeeTy() for: i8* %1
InstructionUtils::inferPointeeTy(): candidate types: i8 | 
InstructionUtils::inferPointeeTy(): res type: i8
AliasAnalysisVisitor::getMemcpySrcTy(): we have no memcpy size info, so try to return the min ty between src and dst.
AliasAnalysisVisitor::getMemcpySrcTy(): minTy: i8
AliasAnalysisVisitor::handleMemcpyFunction(): inferred memcpy ty: i8
[DST PTO] [64 x i8] | -1 ,is_taint_src: 0, Obj ID: 0x1d63970, Inst/Val:   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, loadTag: 
AliasObject::mergeField(): 0x1d2ae60|0 -> 0x1d63970|-1

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %11, i8* align 1 %1, i64 %7, i1 false), !dbg !64
[64 x i8] | 0 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 0 : i8
AliasObject::fetchPointsToObjects: equivalent obj|field identified, cnt: 2
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|-1

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %11, i8* align 1 %1, i64 %7, i1 false), !dbg !64
[64 x i8] | -1 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | -1 : i8
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|-1
FieldTaint::getTf(): fetch taint for field: 0, FieldTaint: 0x1d5fa50, Host: 0x1d2ae60
FieldTaint::getTf(): final stats: total/act_tan/ret: 1/1/1
AliasObject::addFieldTaintFlag(): [64 x i8] | -1 obj: 0x1d63970
FieldTaint::addTf(): add TF for field -1, FieldTaint: 0x1d676d0, Host: 0x1d63970
FieldTaint::addTf(): +++TF: TAG(0x1d5c1f0):i32|0(OBJ:0x1d5bac0,G:0) TF(0x1d64340)  FROM:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62 (entry0 -> random_write_iter -> write_pool_user -> ) TO:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %11, i8* align 1 %1, i64 %7, i1 false), !dbg !64 (entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> blake2s_update -> ) tr_len: 2 tan/inh/act/wea: 1/0/1/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 1/1/1/0/0
[1;94m Processing memcpy function
[0mPathAnalysisVisitor::visitCallInst():   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %11, i8* align 1 %1, i64 %7, i1 false), !dbg !64, callee: llvm.memcpy.p0i8.p0i8.i64
AliasAnalysisVisitor::visitStoreInst():   store i32 0, i32* %4, align 4, !dbg !65, !tbaa !52
visitStoreInst(): src does not point to anything: i32 0; Ignoring.
TaintAnalysisVisitor::visitStoreInst():   store i32 0, i32* %4, align 4, !dbg !65, !tbaa !52
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
AliasObject::addFieldTaintFlag(): %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 4 obj: 0x1d544e0
AliasObject::addFieldTaintFlag(): try to add a taint kill flag, but the target                field hasn't been tainted yet, so no action...
[TIMING] TaintAnalysisVisitor::visitStoreInst(): 1.495100e-05s
AliasAnalysisVisitor::visitGetElementPtrInst():   %12 = getelementptr inbounds i8, i8* %1, i64 %7, !dbg !66
AliasAnalysisVisitor::processGEPFirstDimension():: basePointerTy: i8*
AliasAnalysisVisitor::processGEPFirstDimension(): Non-constant 0st index!
AliasAnalysisVisitor::processMultiDimensionGEP(): updating the point-to for current GEP...
updatePointsToObjects for :   %12 = getelementptr inbounds i8, i8* %1, i64 %7, !dbg !66
InstructionUtils::inferPointeeTy() for:   %12 = getelementptr inbounds i8, i8* %1, i64 %7, !dbg !66
InstructionUtils::inferPointeeTy(): candidate types: i8 | 
InstructionUtils::inferPointeeTy(): res type: i8
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: i8
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | -1 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
[TIMING] AliasAnalysisVisitor::visitGetElementPtrInst(): 5.487100e-05s
updatePointsToObjects for :   %13 = sub i64 %2, %7, !dbg !67
InstructionUtils::inferPointeeTy() for:   %13 = sub i64 %2, %7, !dbg !67
InstructionUtils::inferPointeeTy(): candidate types: 
InstructionUtils::inferPointeeTy(): res type: 
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: 
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
[32mStarting to analyze BB::at:blake2s_update[0m
updatePointsToObjects for :   %15 = phi i64 [ %13, %9 ], [ %2, %3 ]
InstructionUtils::inferPointeeTy() for:   %15 = phi i64 [ %13, %9 ], [ %2, %3 ]
InstructionUtils::inferPointeeTy(): candidate types: 
InstructionUtils::inferPointeeTy(): res type: 
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: 
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
updatePointsToObjects for :   %16 = phi i8* [ %12, %9 ], [ %1, %3 ]
InstructionUtils::inferPointeeTy() for:   %16 = phi i8* [ %12, %9 ], [ %1, %3 ]
InstructionUtils::inferPointeeTy(): candidate types: i8 | 
InstructionUtils::inferPointeeTy(): res type: i8
#newPointsToInfo: 2 #existingPointsTo: 0 expected pointee type: i8
#matchedPtos: 2 #unmatchedPtos: 0
++ PTO: [64 x i8] | -1 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag:   %16 = phi i8* [ %12, %9 ], [ %1, %3 ] [0] -> 
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag:   %16 = phi i8* [ %12, %9 ], [ %1, %3 ] [1] -> 
updatePointsToObjects: #After update: 2
AliasAnalysisVisitor::visitLoadInst():   %17 = load i32, i32* %4, align 4, !dbg !69, !tbaa !52

*********FieldAccess(FETCH)**********
Current Inst:   %17 = load i32, i32* %4, align 4, !dbg !69, !tbaa !52
%struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 4 OBJ: 0x1d544e0
Object Ptr: %struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }
*******************
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
AliasObject::fetchPointsToObjects: No existing pto records for the field, try to create a dummy obj.
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
AliasObject::createFieldPointee(): cannot decide the type of the dummy obj!
AliasAnalysisVisitor::visitLoadInst(): #targetObjects: 1 #finalObjects: 0
[TIMING] AliasAnalysisVisitor::visitLoadInst(): 4.185700e-05s
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
[TIMING] TaintAnalysisVisitor::visitLoadInst(): 7.799000e-06s
AliasAnalysisVisitor::visitCastInst:   %18 = zext i32 %17 to i64, !dbg !70
Convert: i32 --> i64
srcOperand:   %17 = load i32, i32* %4, align 4, !dbg !69, !tbaa !52
Ignoring casting as pointer does not point to anything
AliasAnalysisVisitor::visitGetElementPtrInst():   %19 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %18, !dbg !70
AliasAnalysisVisitor::processGEPFirstDimension():: basePointerTy: %struct.blake2s_state*
AliasAnalysisVisitor::processGEPFirstDimension(): 0st index: 0
About to process index: 1
Index value: 3
AliasAnalysisVisitor::makePointsToCopy(): #elements in *srcPointsTo: 1 
AliasAnalysisVisitor::makePointsToCopy(): basePointerType: %struct.blake2s_state* cur pto: %struct.anon = type { %struct.blake2s_state, i64, i32 } | 0, obj: 0x1d542e0 dst fid: 3
AliasObject::createEmbObj(): host type: %struct.anon = type { %struct.blake2s_state, i64, i32 } | 0 ID: 0x1d542e0
AliasObject::createEmbObj(): ety: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } expectedPointeeTy: 
AliasObject::createEmbObj(): find the previosuly created embed object: 0x1d544e0
AliasAnalysisVisitor::makePointsToCopy(): ++ ret pto: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 3, obj: 0x1d544e0
AliasAnalysisVisitor::makePointsToCopy(): #ret: 1
About to process index: 2
Index value: -1
subGEP:   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3
resGEP:   %19 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %18, !dbg !70
AliasAnalysisVisitor::makePointsToCopy_emb(): elements in *srcPointsTo: 1 
AliasAnalysisVisitor::makePointsToCopy_emb(): host_type: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 3
AliasAnalysisVisitor::makePointsToCopy_emb(): ety: [64 x i8] | -1
AliasAnalysisVisitor::makePointsToCopy_emb(): trying to get/create an object for the embedded struct/array..
AliasObject::createEmbObj(): host type: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 3 ID: 0x1d544e0
AliasObject::createEmbObj(): ety: [64 x i8] expectedPointeeTy: [64 x i8]
AliasObject::createEmbObj(): find the previosuly created embed object: 0x1d63970
updatePointsToObjects for :   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: [64 x i8]
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d63970, Inst/Val:   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, loadTag: 
updatePointsToObjects: #After update: 1
AliasAnalysisVisitor::processMultiDimensionGEP(): updating the point-to for current GEP...
updatePointsToObjects for :   %19 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %18, !dbg !70
InstructionUtils::inferPointeeTy() for:   %19 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %18, !dbg !70
InstructionUtils::inferPointeeTy(): candidate types: i8 | 
InstructionUtils::inferPointeeTy(): res type: i8
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: i8
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | -1 ,is_taint_src: 0, Obj ID: 0x1d63970, Inst/Val:   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, loadTag: 
updatePointsToObjects: #After update: 1
[TIMING] AliasAnalysisVisitor::visitGetElementPtrInst(): 1.628740e-04s
GlobalVisitor::processCalledFunction: prepare context for: llvm.memcpy.p0i8.p0i8.i64 (w/o definition)
AliasAnalysisVisitor::visitCallInst():   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
AliasAnalysisVisitor::visitCallInst(): This is a memcpy function w/o definition.
AliasAnalysisVisitor::handleMemcpyFunction(): Processing memcpy function.
AliasAnalysisVisitor::getMemcpySrcTy(): memcpy size: 0
InstructionUtils::inferPointeeTy() for:   %19 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, i64 %18, !dbg !70
InstructionUtils::inferPointeeTy(): res type: i8
InstructionUtils::inferPointeeTy() for:   %16 = phi i8* [ %12, %9 ], [ %1, %3 ]
InstructionUtils::inferPointeeTy(): res type: i8
AliasAnalysisVisitor::getMemcpySrcTy(): we have no memcpy size info, so try to return the min ty between src and dst.
AliasAnalysisVisitor::getMemcpySrcTy(): minTy: i8
AliasAnalysisVisitor::handleMemcpyFunction(): inferred memcpy ty: i8
[DST PTO] [64 x i8] | -1 ,is_taint_src: 0, Obj ID: 0x1d63970, Inst/Val:   <badref> = getelementptr %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 3, loadTag: 
AliasObject::mergeField(): 0x1d2ae60|-1 -> 0x1d63970|-1

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | -1 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | -1 : i8
AliasObject::fetchPointsToObjects: equivalent obj|field identified, cnt: 65
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|0

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 0 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 0 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|1

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 1 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 1 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|2

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 2 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 2 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|3

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 3 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 3 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|4

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 4 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 4 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|5

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 5 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 5 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|6

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 6 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 6 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|7

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 7 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 7 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|8

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 8 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 8 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|9

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 9 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 9 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|10

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 10 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 10 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|11

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 11 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 11 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|12

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 12 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 12 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|13

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 13 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 13 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|14

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 14 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 14 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|15

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 15 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 15 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|16

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 16 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 16 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|17

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 17 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 17 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|18

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 18 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 18 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|19

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 19 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 19 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|20

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 20 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 20 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|21

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 21 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 21 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|22

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 22 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 22 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|23

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 23 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 23 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|24

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 24 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 24 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|25

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 25 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 25 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|26

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 26 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 26 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|27

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 27 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 27 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|28

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 28 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 28 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|29

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 29 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 29 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|30

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 30 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 30 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|31

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 31 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 31 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|32

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 32 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 32 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|33

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 33 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 33 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|34

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 34 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 34 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|35

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 35 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 35 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|36

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 36 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 36 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|37

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 37 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 37 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|38

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 38 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 38 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|39

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 39 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 39 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|40

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 40 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 40 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|41

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 41 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 41 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|42

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 42 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 42 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|43

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 43 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 43 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|44

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 44 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 44 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|45

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 45 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 45 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|46

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 46 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 46 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|47

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 47 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 47 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|48

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 48 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 48 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|49

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 49 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 49 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|50

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 50 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 50 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|51

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 51 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 51 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|52

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 52 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 52 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|53

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 53 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 53 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|54

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 54 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 54 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|55

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 55 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 55 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|56

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 56 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 56 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|57

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 57 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 57 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|58

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 58 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 58 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|59

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 59 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 59 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|60

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 60 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 60 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|61

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 61 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 61 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|62

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 62 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 62 : i8
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|63

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 63 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 63 : i8
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|5
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|4
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|3
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|2
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|1
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|0
FieldTaint::getTf(): fetch taint for field: 0, FieldTaint: 0x1d5fa50, Host: 0x1d2ae60
FieldTaint::getTf(): final stats: total/act_tan/ret: 1/1/1
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|63
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|62
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|55
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|56
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|57
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|58
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|59
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|60
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|61
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|54
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|47
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|48
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|49
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|50
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|51
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|52
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|53
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|46
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|39
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|40
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|41
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|42
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|43
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|44
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|45
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|38
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|31
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|32
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|33
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|34
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|35
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|36
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|37
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|30
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|23
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|24
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|25
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|26
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|27
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|28
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|29
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|22
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|15
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|16
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|17
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|18
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|19
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|20
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|21
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|14
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|7
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|8
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|9
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|10
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|11
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|12
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|13
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|6
AliasObject::addFieldTaintFlag(): [64 x i8] | -1 obj: 0x1d63970
FieldTaint::addTf(): add TF for field -1, FieldTaint: 0x1d676d0, Host: 0x1d63970
FieldTaint::addTf(): +++TF: TAG(0x1d5c1f0):i32|0(OBJ:0x1d5bac0,G:0) TF(0x1d65680)  FROM:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62 (entry0 -> random_write_iter -> write_pool_user -> ) TO:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71 (entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> blake2s_update -> ) tr_len: 2 tan/inh/act/wea: 1/0/1/0
FieldTaint::addTf(): ---TF: TAG(0x1d5c1f0):i32|0(OBJ:0x1d5bac0,G:0) TF(0x1d64340)  FROM:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 dereferenceable(64) %3, i8* nonnull align 1 dereferenceable(64) %0, i64 64, i1 false), !dbg !62 (entry0 -> random_write_iter -> write_pool_user -> ) TO:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %11, i8* align 1 %1, i64 %7, i1 false), !dbg !64 (entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> blake2s_update -> ) tr_len: 2 tan/inh/act/wea: 1/0/0/0
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 2/2/1/0/0
AliasObject::mergeField(): 0x1d2ae60|0 -> 0x1d63970|-1

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | 0 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | 0 : i8
AliasObject::fetchPointsToObjects: equivalent obj|field identified, cnt: 2
AliasObject::fetchPointsToObjects: ~~>[EQV OBJ] 0x1d2ae60|-1

*********FieldAccess(FETCH)**********
Current Inst:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71
[64 x i8] | -1 OBJ: 0x1d2ae60
Object Ptr:   %2 = alloca [64 x i8], align 16
*******************
AliasObject::getNestedObj(): 0x1d2ae60 | -1 : i8
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|-1
FieldTaint::getTf(): fetch taint for field: 0, FieldTaint: 0x1d5fa50, Host: 0x1d2ae60
FieldTaint::getTf(): final stats: total/act_tan/ret: 1/1/1
AliasObject::addFieldTaintFlag(): [64 x i8] | -1 obj: 0x1d63970
FieldTaint::addTf(): add TF for field -1, FieldTaint: 0x1d676d0, Host: 0x1d63970
FieldTaint::addTf(): post-stats: total/tan/act/inh/weak: 2/2/1/0/0
[1;94m Processing memcpy function
[0mPathAnalysisVisitor::visitCallInst():   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %19, i8* align 1 %16, i64 %15, i1 false), !dbg !71, callee: llvm.memcpy.p0i8.p0i8.i64
AliasAnalysisVisitor::visitLoadInst():   %20 = load i32, i32* %4, align 4, !dbg !72, !tbaa !52

*********FieldAccess(FETCH)**********
Current Inst:   %20 = load i32, i32* %4, align 4, !dbg !72, !tbaa !52
%struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 4 OBJ: 0x1d544e0
Object Ptr: %struct.blake2s_state { [8 x i32] [i32 1795745351, i32 -1150833019, i32 1013904242, i32 -1521486534, i32 1359893119, i32 -1694144372, i32 528734635, i32 1541459225], [2 x i32] zeroinitializer, [2 x i32] zeroinitializer, [64 x i8] zeroinitializer, i32 0, i32 32 }
*******************
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
AliasObject::fetchPointsToObjects: No existing pto records for the field, try to create a dummy obj.
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
AliasObject::createFieldPointee(): cannot decide the type of the dummy obj!
AliasAnalysisVisitor::visitLoadInst(): #targetObjects: 1 #finalObjects: 0
[TIMING] AliasAnalysisVisitor::visitLoadInst(): 4.680900e-05s
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
[TIMING] TaintAnalysisVisitor::visitLoadInst(): 7.782000e-06s
AliasAnalysisVisitor::visitCastInst:   %21 = trunc i64 %15 to i32, !dbg !72
Convert: i64 --> i32
srcOperand:   %15 = phi i64 [ %13, %9 ], [ %2, %3 ]
AliasAnalysisVisitor::visitCastInst(): current target object: [64 x i8] | 0
AliasAnalysisVisitor::visitCastInst(): the cast destination is not a pointer                , simply propagate the point-to record from src to dst...
updatePointsToObjects for :   %21 = trunc i64 %15 to i32, !dbg !72
InstructionUtils::inferPointeeTy() for:   %21 = trunc i64 %15 to i32, !dbg !72
InstructionUtils::inferPointeeTy(): candidate types: 
InstructionUtils::inferPointeeTy(): res type: 
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: 
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
updatePointsToObjects for :   %22 = add i32 %20, %21, !dbg !72
InstructionUtils::inferPointeeTy() for:   %22 = add i32 %20, %21, !dbg !72
InstructionUtils::inferPointeeTy(): candidate types: 
InstructionUtils::inferPointeeTy(): res type: 
#newPointsToInfo: 1 #existingPointsTo: 0 expected pointee type: 
#matchedPtos: 1 #unmatchedPtos: 0
++ PTO: [64 x i8] | 0 ,is_taint_src: 0, Obj ID: 0x1d2ae60, Inst/Val:   %2 = alloca [64 x i8], align 16, loadTag: 
updatePointsToObjects: #After update: 1
AliasAnalysisVisitor::visitStoreInst():   store i32 %22, i32* %4, align 4, !dbg !72, !tbaa !52
inferSrcDstMap(): #srcPointsTo: 1 #dstPointsTo: 1
updateFieldPointsTo() for: %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 4 Host Obj ID: 0x1d544e0
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
updateFieldPointsTo_do(): add and activate point-to: host: 0x1d544e0, 4 -> [64 x i8] | 0 Tgt Obj ID: 0x1d2ae60
updateFieldPointsTo_do(): After updates: Field Pto: 0x1d544e0 | 4 : #Total: 1 #Active: 1 #Strong: 1
[TIMING] AliasAnalysisVisitor::visitStoreInst(): 5.559500e-05s
TaintAnalysisVisitor::visitStoreInst():   store i32 %22, i32* %4, align 4, !dbg !72, !tbaa !52
AliasObject::getNestedObj(): 0x1d544e0 | 4 : i32
AliasObject::addFieldTaintFlag(): %struct.blake2s_state = type { [8 x i32], [2 x i32], [2 x i32], [64 x i8], i32, i32 } | 4 obj: 0x1d544e0
AliasObject::addFieldTaintFlag(): try to add a taint kill flag, but the target                field hasn't been tainted yet, so no action...
[TIMING] TaintAnalysisVisitor::visitStoreInst(): 1.443600e-05s
[TIMING] End func(11) blake2s_update in: 3.808786e-03s
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> 
[TIMING] End func(9) _mix_pool_bytes in: 3.933723e-03s
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> 
[TIMING] End func(7) mix_pool_bytes in: 4.039067e-03s
CTX: entry0 -> random_write_iter -> write_pool_user -> 
GlobalVisitor::processCalledFunction: prepare context for: iov_iter_count (w/o definition)
AliasAnalysisVisitor::visitCallInst():   %7 = call i32 (i8*, ...) bitcast (i32 (...)* @iov_iter_count to i32 (i8*, ...)*)(i8* %0) #4, !dbg !64
AliasAnalysisVisitor::visitCallInst(): Handle the Function: iov_iter_count in the default way.
AliasAnalysisVisitor::visitCallInst(): not handled!
PathAnalysisVisitor::visitCallInst():   %7 = call i32 (i8*, ...) bitcast (i32 (...)* @iov_iter_count to i32 (i8*, ...)*)(i8* %0) #4, !dbg !64, callee: iov_iter_count
PathAnalysisVisitor::visitBranchInst(): Processing BR:   br i1 %9, label %10, label %6, !dbg !65, !llvm.loop !66, pred: 32, sc: 1, uc: 1
[32mStarting to analyze BB::at:write_pool_user[0m
GlobalVisitor::processCalledFunction: prepare context for: llvm.lifetime.end.p0i8 (w/o definition)
AliasAnalysisVisitor::visitCallInst():   call void @llvm.lifetime.end.p0i8(i64 64, i8* nonnull %3) #4, !dbg !69
AliasAnalysisVisitor::visitCallInst(): Handle the Function: llvm.lifetime.end.p0i8 in the default way.
AliasAnalysisVisitor::visitCallInst(): not handled!
PathAnalysisVisitor::visitCallInst():   call void @llvm.lifetime.end.p0i8(i64 64, i8* nonnull %3) #4, !dbg !69, callee: llvm.lifetime.end.p0i8
[TIMING] End func(5) write_pool_user in: 1.378073e-02s
CTX: entry0 -> random_write_iter -> 
[TIMING] End func(3) random_write_iter in: 1.387903e-02s
CTX: entry0 -> 
GlobalVisitor::processCalledFunction: prepare context for: llvm.lifetime.end.p0i8 (w/o definition)
AliasAnalysisVisitor::visitCallInst():   call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %5) #4, !dbg !57
AliasAnalysisVisitor::visitCallInst(): Handle the Function: llvm.lifetime.end.p0i8 in the default way.
AliasAnalysisVisitor::visitCallInst(): not handled!
PathAnalysisVisitor::visitCallInst():   call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %5) #4, !dbg !57, callee: llvm.lifetime.end.p0i8
[TIMING] End func(1) entry0 in: 1.465526e-02s
[TIMING] Anlysis of entry0 done in : 1.481347e-02s
[TIMING] Clean up GlobalVisitor at: Sat Nov 22 06:06:23 2025

[TIMING] All main anlysis done in : 1.488962e-02s
=========================Bug Detection Phase=========================
[TIMING] Bug Detection Phase Starts : Sat Nov 22 06:06:23 2025

CTX: entry0 ->
[TIMING] Start func(1) entry0: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:entry0[0m
TaintedPointerDereferenceChecker says:[1;94m Visiting Store Instruction: [0m  store i32 %0, i32* %3, align 4, !tbaa !49
[DEBUG] ptr =   %3 = alloca i32, align 4
GlobalVisitor::processCalledFunction: prepare context for: llvm.lifetime.start.p0i8 (w/o definition)
GlobalVisitor::processCalledFunction: prepare context for: copy_from_user (w/o definition)
GlobalVisitor::processCalledFunction: prepare context for: random_write_iter (w/ definition)
Analyzing new function: random_write_iter Call depth: 3
CTX: entry0 -> random_write_iter -> 
[TIMING] Start func(3) random_write_iter: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:random_write_iter[0m
GlobalVisitor::processCalledFunction: prepare context for: write_pool_user (w/ definition)
Analyzing new function: write_pool_user Call depth: 5
CTX: entry0 -> random_write_iter -> write_pool_user -> 
[TIMING] Start func(5) write_pool_user: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:write_pool_user[0m
GlobalVisitor::processCalledFunction: prepare context for: llvm.lifetime.start.p0i8 (w/o definition)
[32mStarting to analyze BB::at:write_pool_user[0m
GlobalVisitor::processCalledFunction: prepare context for: llvm.memcpy.p0i8.p0i8.i64 (w/o definition)
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d0ce00|-1
FieldTaint::getTf(): fetch taint for field: 0, FieldTaint: 0x1d5c290, Host: 0x1d5bac0
FieldTaint::getTf(): final stats: total/act_tan/ret: 1/1/1
getAllUserTaintChains(): enum user taint chains for TF: 0x1d5c220 TAG: TAG(0x1d5c1f0):i32|0(OBJ:0x1d5bac0,G:0)
getAllUserTaintChains(): this is already a user taint tag, return the TF trace directly!
[31m[TPD] memcpy src memory HAS user taint![0m
GlobalVisitor::processCalledFunction: prepare context for: mix_pool_bytes (w/ definition)
Analyzing new function: mix_pool_bytes Call depth: 7
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> 
[TIMING] Start func(7) mix_pool_bytes: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:mix_pool_bytes[0m
GlobalVisitor::processCalledFunction: prepare context for: _mix_pool_bytes (w/ definition)
Analyzing new function: _mix_pool_bytes Call depth: 9
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> 
[TIMING] Start func(9) _mix_pool_bytes: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:_mix_pool_bytes[0m
GlobalVisitor::processCalledFunction: prepare context for: blake2s_update (w/ definition)
Analyzing new function: blake2s_update Call depth: 11
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> blake2s_update -> 
[TIMING] Start func(11) blake2s_update: Sat Nov 22 06:06:23 2025

[32mStarting to analyze BB::at:blake2s_update[0m
TaintedPointerDereferenceChecker says: Visiting Load Instruction:   %5 = load i32, i32* %4, align 4, !dbg !51, !tbaa !52
[32mStarting to analyze BB::at:blake2s_update[0m
GlobalVisitor::processCalledFunction: prepare context for: llvm.memcpy.p0i8.p0i8.i64 (w/o definition)
[31m[TPD] store to global: [0m
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|-1
FieldTaint::getTf(): fetch taint for field: 0, FieldTaint: 0x1d5fa50, Host: 0x1d2ae60
FieldTaint::getTf(): final stats: total/act_tan/ret: 1/1/1
getAllUserTaintChains(): enum user taint chains for TF: 0x1d5f9c0 TAG: TAG(0x1d5c1f0):i32|0(OBJ:0x1d5bac0,G:0)
getAllUserTaintChains(): this is already a user taint tag, return the TF trace directly!
[31m[TPD] memcpy src memory HAS user taint![0m
[103;30m[VUL] Store taint value in global![0m
TaintedPointerDereferenceChecker says:[1;94m Visiting Store Instruction: [0m  store i32 0, i32* %4, align 4, !dbg !65, !tbaa !52
[DEBUG] ptr =   %4 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 4, !dbg !51
[31m[TPD] store to global: [0m
[32mStarting to analyze BB::at:blake2s_update[0m
TaintedPointerDereferenceChecker says: Visiting Load Instruction:   %17 = load i32, i32* %4, align 4, !dbg !69, !tbaa !52
GlobalVisitor::processCalledFunction: prepare context for: llvm.memcpy.p0i8.p0i8.i64 (w/o definition)
[31m[TPD] store to global: [0m
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|0
FieldTaint::getTf(): fetch taint for field: 0, FieldTaint: 0x1d5fa50, Host: 0x1d2ae60
FieldTaint::getTf(): final stats: total/act_tan/ret: 1/1/1
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|12
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|13
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|14
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|15
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|16
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|17
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|18
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|19
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|20
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|21
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|22
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|23
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|24
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|25
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|26
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|27
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|28
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|29
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|30
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|31
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|32
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|33
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|34
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|35
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|36
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|37
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|38
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|39
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|40
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|41
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|42
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|43
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|44
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|45
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|46
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|47
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|48
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|49
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|50
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|51
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|52
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|53
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|54
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|55
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|56
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|57
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|58
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|59
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|60
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|61
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|62
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|63
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|1
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|4
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|2
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|3
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|11
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|6
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|7
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|8
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|9
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|10
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|5
AliasObject::getFieldTaintInfo(): ~~>[EQV OBJ] 0x1d2ae60|-1
FieldTaint::getTf(): fetch taint for field: 0, FieldTaint: 0x1d5fa50, Host: 0x1d2ae60
FieldTaint::getTf(): final stats: total/act_tan/ret: 1/1/1
getAllUserTaintChains(): enum user taint chains for TF: 0x1d5f9c0 TAG: TAG(0x1d5c1f0):i32|0(OBJ:0x1d5bac0,G:0)
getAllUserTaintChains(): this is already a user taint tag, return the TF trace directly!
[31m[TPD] memcpy src memory HAS user taint![0m
[103;30m[VUL] Store taint value in global![0m
TaintedPointerDereferenceChecker says: Visiting Load Instruction:   %20 = load i32, i32* %4, align 4, !dbg !72, !tbaa !52
TaintedPointerDereferenceChecker says:[1;94m Visiting Store Instruction: [0m  store i32 %22, i32* %4, align 4, !dbg !72, !tbaa !52
[DEBUG] ptr =   %4 = getelementptr inbounds %struct.blake2s_state, %struct.blake2s_state* %0, i64 0, i32 4, !dbg !51
[31m[TPD] store to global: [0m
[TIMING] End func(11) blake2s_update in: 4.685440e-04s
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> _mix_pool_bytes -> 
[TIMING] End func(9) _mix_pool_bytes in: 5.281270e-04s
CTX: entry0 -> random_write_iter -> write_pool_user -> mix_pool_bytes -> 
[TIMING] End func(7) mix_pool_bytes in: 5.844420e-04s
CTX: entry0 -> random_write_iter -> write_pool_user -> 
GlobalVisitor::processCalledFunction: prepare context for: iov_iter_count (w/o definition)
[32mStarting to analyze BB::at:write_pool_user[0m
GlobalVisitor::processCalledFunction: prepare context for: llvm.lifetime.end.p0i8 (w/o definition)
[TIMING] End func(5) write_pool_user in: 7.209610e-04s
CTX: entry0 -> random_write_iter -> 
[TIMING] End func(3) random_write_iter in: 7.711960e-04s
CTX: entry0 -> 
GlobalVisitor::processCalledFunction: prepare context for: llvm.lifetime.end.p0i8 (w/o definition)
[TIMING] End func(1) entry0 in: 8.534890e-04s
[TIMING][Bug-Detection] Anlysis of entry0 done in : 9.104640e-04s
[TIMING][Bug-Detection] Clean up GlobalVisitor at: Sat Nov 22 06:06:23 2025

[TIMING] Bug Detection Phase finished in : 8.835860e-04s
[+] Writing output to:benchmark/conf_rand.warn.json
[+] Return message from file write:Success
[+] Writing Instr output to:benchmark/conf_rand.iwarn.json
[+] Return message from file write:Success
All done: Sat Nov 22 06:06:23 2025

===-------------------------------------------------------------------------===
                            Range Analysis algorithm
===-------------------------------------------------------------------------===
  Total Execution Time: 0.0001 seconds (0.0002 wall clock)

   ---User Time---   --System Time--   --User+System--   ---Wall Time---  --- Name ---
   0.0000 (100.0%)   0.0000 ( 38.5%)   0.0001 ( 49.7%)   0.0001 ( 47.4%)  Build constraint graph
   0.0000 (  0.0%)   0.0001 ( 43.6%)   0.0001 ( 35.7%)   0.0001 ( 39.0%)  Nuutila's algorithm for strongly connected components
   0.0000 (  0.0%)   0.0000 ( 14.5%)   0.0000 ( 11.9%)   0.0000 ( 10.6%)  Constraint solving
   0.0000 (  0.0%)   0.0000 (  3.4%)   0.0000 (  2.8%)   0.0000 (  3.0%)  Compute statistics
   0.0000 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)   0.0002 (100.0%)  Total

[32mGot Traversal order For: entry0[0m
